# Introduction
The Bee Project consists of a 3-dimensional grid with bees that must travel to a set of 15 end points in a continuous line in the least amount of direction changes. We decided early to use A\*, a path finding algorithm which is a heuristic version of Dijkstra's algorithm. The inclusion of heuristics allows Dijkstra's algorithm to be much more suited to path finding, as the algorithm will naturally head towards the point thanks to your heuristic algorithm. Additionally, being based of Dijkstra's, as long as the heuristics are balanced and not overly strong, the shortest possible path will be ensured.
# Version 1
## Parser
We used a buffered reader to open and read the file as it's one of the most performant out of the main readers. Additionally, the single line reading nature wasn't a downside at all in this case, since new lines separated the data. We used a line counter to determine what the line of data would be for, the cycle count, grid size, be position, obstacles counts, or obstacle position. For bee and obstacle positions as well as grid size, we grabbed the line, split it by the commas, and then parsed the number before creating a new `Point` objects to add to a list or to a size variable. The `Point` class consisted of the position and a `boolean` to determine whether it was an obstacle. After we had everything, we created a `Grid3D` object that contained a 3-dimensional array of `Point` objects, and we looped through the obstacles to set each obstacle point in the 3-dimensional array to be an obstacle.
## A\* Pathing
We started off originally with a 2-dimensional version of the project as adding the 3rd dimension will add much more nodes, adding much more complexity as well as nodes, slowing down the runtime. We used the 2-dimensional version until our basic A\* was complete before jumping to a 3-dimensional version. We used a mostly traditional A\* implementation using a `HashMap` that contained the minimum distance of a node, and its previous node. However instead of a `PriorityQueue` (a list of items that allows to you grab the highest priority, in the scenario of A\* the distance + heuristic weighting), we used an `ArrayList`. We would sort said `ArrayList` every time we wanted to grab an item. The decision to use the `ArrayList` despite the horrible performance was due to the fact that custom `PriorityQueue` comparators usually end up wasting a lot of early debugging time. The heuristics we used were just the average Euclidean's distance from all the end points.
Once we have visited all the end points, we grabbed the distances from all the end points and grabbed the minimum points, retraced the path using the previous points that were stored and printed them the distance and path.
## Next Node Generation
In order to grab the next nodes/points from the current point, we used a for loop with guard statements to iterate in all 6 linear directions and then the 12 two axis diagonals. (We didn't include the other 8 three axis diagonals as the project disallowed three axis movement) until we hit a wall, the edge of the grid, or an invalid diagonal spot. In order for a diagonal spot to be valid, there must be another intermediate point that it can move through. The “distance”/weighting of each node was all one, to imply a single direction change. Since A\* wants the shortest path, moving twice in the same direction would end up being overridden by the one move.
# Version 1.1
Once we had the basic 3-dimensional version, we ended up making the custom comparator for the `PriorityQueue` and switching to said `PriorityQueue` in order to fix the performance issues that came from adding the third dimension. Additionally, we were able to exit once we reached just one of the 15 end nodes rather than all 15 as long as the heuristics were balanced, the first visited end node would also be the closest one. We then finally switched the heuristics to Manhattan's distance, as it was slightly closer to the movement system we used. Since we also only need one end node, the heuristic distance was only for the minimum of the end points, rather than the average. We didn't use anything that did heuristics based on open stretches available and distance, since that would add much more complexity and probably end up negatively impacting performance. The final runtime of version 1 was 2.4 seconds.
# Version 2
## New Node Generation, Part 1
The old node generation made the pathing algorithm visit a lot of useless nodes. If a node didn't have any other nodes in a direction other than the one that you would have to travel in to reach it from the original. For diagonal points, there would be a node either way, since there had to be an intermediate point we moved through to the side. This way we only had to focus on the lines, we just had to make sure that one of the four other sides of the node were empty. (We don't have to consider diagonals as if all four sides are blocked, there is no intermediate step). There is only one exception to this case which is if the node being considered is one of the end points, in that case we would include the node either way as we don't want to skip over the end nodes. Once again we started with a 3-dimensional version, instead of coding it in java, we started in HTML and JavaScript, making an interactive visualizer. It displayed a 2-dimensional grid, with a green start point, and blue points for the next nodes, and gray for the obstacles. The bright blue points were the ones with the empty side nodes and would include in the final result given to A\* while the dark blue points would be pruned off.

[![Watch the video](https://github.com/user-attachments/assets/1260f2ac-37d1-46f8-bcfc-630a598e2bbd)](https://files.catbox.moe/p364yk.mp4)
**(Click to open video link)**

The way the nodes were generated was using two functions, `rookPath` and `bishopPath` which took in `-1`, `0`, or `1` to symbolize the direction of the ray of nodes would be in. `rookPath` was for straight lines much like the movement of rooks in chess while the `bishopPath` function was for diagonals. 

<img width="983" height="645" alt="Pasted image 20240207124109" src="https://github.com/user-attachments/assets/b0b02b42-cdc5-421b-887d-c8810a803f1b" />

## New Node Generation, Part 2
Since a three-dimensional grid would be hard to display with just basic HTML, and JavaScript, we decided to switch to a Three.js visualizer for the three-dimensional grid, while this version didn't allow you to change the start node live, you could still view the next nodes and obstacles live. The start point was a white cube, obstacles were black cubes, and empty non-next nodes were transparent with only the black border on all the cubes. The purple cubes were the equivalent of the bright blue cubes from before, the gray cubes were the equivalent of the dark blue cubes.

[![Watch the video](https://github.com/user-attachments/assets/fe0e0f35-b233-43b1-83c8-cb01b208b913)](https://files.catbox.moe/m3wgnh.mp4)
**(Click to open video link)**

## Pathing, Version 2 | Maps
After we had the node generation, done, we created a basic JavaScript A\* with an array as JavaScript array sorting is much faster than JavaScript `PriorityQueue`s as JavaScript wasn't designed for custom heap based data structures, and they wouldn't be as compiler optimized. After we verified it all worked, we ported the node generator to Java and started work on our new A\* implementation. Striving of squeezing as much performance as possible, we completely ditched the `PriorityQueue` + `HashMap` for a `HashMap` based implementation. This was as the majority of the runtime of the previous version was spent on removing items from the `PriorityQueue` for reinsertion to update its position, making up 79.5% (1.9 seconds out of 2.4 seconds). We started with the unseen list becoming a `HashMap` using a `String` version of the node as a key for the heuristic value. The minimum distances map became a `TreeMap` (an implementation of a `SortedMap`) that used an int (the distance) as the key for another `TreeMap`, which took a string version of a node as the key for the string version of the previous node.  The minimum distances `TreeMap` was sorted least to greatest based on the distance. To grab the new node to visit, we would loop through the minimum distances `TreeMap`. We would then loop through the inner `TreeMap` of `Node` objects as the key, and the previous `Node` was the value. We did this until we found an entry where the key was the in the unseen map. Once we've successfully found one, we would grab it, and then remove it from the unseen map. We grabbed the neighbors after that, and looped through them. For each neighbor we looped through the minimum map to see if there was already a distance entered, if yes we saved it, checked if the new distance was less than the previous. If that was the case, we would remove the previous entry under the previous distance map. For both cases of insertion, depending on whether a map existed for the new distance, we would either add a new entry with a new `TreeMap` or add a new entry to the previous `TreeMap`. The entry would have the neighbor string as the key and the current node as the value.
## Pathing, Version 2.1 | Heuristic Balancing
Like before, we had been using Manhattan's distance to find the distance, however the distance was just plainly given to the A\* algorithm This meant that the heuristic weighting would over saturate the valuing of each node and made our A\* closer to a greedy algorithm. We ended up trying multiple different multipliers to balance the importance of the heuristic value and settled on 0.25 which allowed fast runtime alongside short paths.
#### Old Paths:

<img width="249" height="424" alt="Pasted image 20240207131713" src="https://github.com/user-attachments/assets/f44d0919-0949-4fe3-804c-2f88c11f25a8" />

#### New Paths:

<img width="204" height="417" alt="Pasted image 20240207130656" src="https://github.com/user-attachments/assets/e8335c4d-cf41-42f1-a994-524afbf8e439" />

## Pathing, Version 2.2 | `Node` Hashing
Currently we were using string versions of the `Node` objects for most things however this led to many `Node` to `String` or `String` to `Node` conversions which used up a lot of time. This was due to the fact that the default hashing and comparison of objects is based off the memory address. We overrode the default behavior, instead hashing and comparing based of the `Node` object's positions, dramatically reducing runtime.
## Pathing, Version 2.3 | Skipping previous & `HashSet`s
As the bee project specifications only required the bee start node, end node, and direction change count rather than the full path, we could entirely remove the previous node. This allowed us to change the inner `TreeMap` of the minimum map that contained the node, and its previous node, to simply a `HashSet` of the nodes. This however ended up actually increasing the runtime by 80 ms, likely due to some difference between `HashSet`s and `TreeMap`s for finding elements or the creation of new hash sets.
## Other Changes
There were a few other minor changes to various parts of the overall code. One of these changes was adding data validation checks to the parser. It ensured that all the end points were continuous and in one single direction, as well as that the obstacle count matched the count provided by the data file

# Runtime Optimization
Our original version of the project had a runtime of over 13 seconds. After switching off a `ArrayList` to a `PriorityQueue`, we dropped by 9 seconds to only 4 seconds. With the rest of the optimizations, such as skipping the need for all 15 end nodes and using better heuristics, the runtime was only 2.4 seconds. However, with the introduction of version 2 and all the optimizations up to version 2.2 (2.3 slowed the program down), the runtime was down to only 230-260 ms or over a 56 times improvement from the first iteration.
